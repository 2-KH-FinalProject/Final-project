<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>관리자 공연 목록</title>
	<link rel="stylesheet" href="/css/main-style.css">
	<th:block th:replace="~{common/common}"></th:block>
	<style>
		.performance-container {
			max-width: 1200px;
			margin: 0 auto;
			padding: 20px;
		}

		.performance-grid {
			display: grid;
			grid-template-columns: repeat(5, 1fr);
			gap: 20px;
			margin-bottom: 30px;
		}

		.performance-item {
			border: 1px solid #eee;
			border-radius: 8px;
			overflow: hidden;
			transition: transform 0.3s ease;
			cursor: pointer;
			contain: content;
		}

		.performance-item:hover {
			transform: translateY(-5px);
			box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
		}

		.performance-image {
			width: 100%;
			height: 280px;
			object-fit: cover;
			display: block;
			background-color: #f5f5f5;
			will-change: transform;
			contain: content;
			backface-visibility: hidden;
			-webkit-backface-visibility: hidden;
			image-rendering: -webkit-optimize-contrast;
			transform: translateZ(0);
			-webkit-transform: translateZ(0);
		}

		.performance-info {
			padding: 15px;
		}

		.performance-title {
			font-size: 16px;
			font-weight: bold;
			margin-bottom: 8px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.performance-date {
			font-size: 14px;
			color: #666;
			line-height: 1.4;
		}

		.performance-venue {
			font-size: 13px;
			color: #888;
			margin-top: 5px;
		}

		.parent {
			display: flex;
			justify-content: center;
			align-items: center;
		}

		h3 {
			margin-top: 100px;
			margin-bottom: 15px;
			font-weight: 600;
		}

		/* 스피너 컨테이너: 화면 중앙 정렬 */
		.loading-spinner {
			display: none;
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 9999;
		}

		.loading-spinner.show {
			display: flex;
			/* 필요할 때만 보이도록 변경 */
		}

		/* 로딩 스피너 애니메이션 */
		.loading-spinner::before {
			display: flex;
			/* 필요할 때만 보이도록 변경 */
			content: "";
			width: 50px;
			height: 50px;
			border: 5px solid rgba(0, 0, 0, 0.1);
			border-top: 5px solid #3498db;
			border-radius: 50%;
			animation: spin 1s linear infinite;
			/* 회전 애니메이션 */
		}

		.image-container {
			position: relative;
			padding-top: 140%;
			background: #f5f5f5;
			overflow: hidden;
			transform: translateZ(0);
			-webkit-transform: translateZ(0);
		}

		.image-container img {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			opacity: 1;
			transition: opacity 0.2s ease;
			transform: translateZ(0);
			-webkit-transform: translateZ(0);
		}

		.image-container img.loaded {
			opacity: 1;
		}

		@media (max-width: 768px) {
			.performance-grid {
				grid-template-columns: repeat(2, 1fr);
			}

			.performance-image {
				height: 200px;
			}
		}

		/* 회전 애니메이션 정의 */
		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}

			100% {
				transform: rotate(360deg);
			}
		}
	</style>
</head>

<body>
	<th:block th:replace="~{common/header}"></th:block>

	<div class="parent">
		<h3 th:text="${genre}">둘러보기</h3>
	</div>

	<div class="performance-container">
		<div class="performance-grid" id="performanceGrid">
			<th:block th:each="performance : ${performances}">
				<div class="performance-item"
					th:onclick="|location.href='@{/performance/detail/{mt20id}(mt20id=${performance.mt20id})}'|">
					<div class="image-container">
						<img th:src="${performance.poster}" th:alt="${performance.prfnm}" class="performance-image"
							loading="lazy" decoding="async">
					</div>
					<div class="performance-info">
						<div class="performance-title" th:text="${performance.prfnm}">공연 제목</div>
						<div class="performance-date">
							<span th:text="${performance.prfpdfrom}">시작일</span> ~
							<span th:text="${performance.prfpdto}">종료일</span>
						</div>
						<div class="performance-venue" th:text="${performance.fcltynm}">공연장</div>
					</div>
				</div>
			</th:block>
		</div>
		<div class="loading-spinner" style="display: none;">
			Loading...
		</div>
	</div>

	<th:block th:replace="~{common/footer}"></th:block>

	<script th:inline="javascript">
		let page = 1;
		let isLoading = false;
		let hasMoreData = true;
		const genre = /*[[${genre}]]*/ null;
		const imageCache = new Map();

		function escapeHtml(unsafe) {
			return unsafe
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&#039;");
		}

		function getCurrentGenre() {
			const path = window.location.pathname;
			const match = path.match(/genre\/([^/]+)$/);
			if (match) {
				let urlGenre = match[1];
				switch (urlGenre) {
					case 'musical':
						return '뮤지컬';
					case 'theater':
						return '연극';
					case 'classic':
						return '서양음악(클래식)';
					default:
						return urlGenre;
				}
			}
			console.error('Cannot determine genre from URL:', path);
			return null;
		}

		function createPerformanceElement(performance) {
			const div = document.createElement('div');
			div.className = 'performance-item';
			div.onclick = () => location.href = `/performance/detail/${performance.mt20id}`;

			// 이미지를 미리 생성하고 속성 설정
			const img = new Image();
			img.src = performance.poster;
			img.className = 'performance-image';
			img.alt = performance.prfnm;
			img.loading = 'lazy';
			img.decoding = 'async';

			// 이미지 로드 완료 시 한 번만 처리
			if (!img.complete) {
				img.onload = function () {
					this.classList.add('loaded');
					img.onload = null;
				};
			} else {
				img.classList.add('loaded');
			}

			// 에러 처리 강화
			img.onerror = function () {
				if (this.src !== '/images/default-poster.png') {
					this.src = '/images/default-poster.png';
				}
				this.onerror = null;
			};

			div.innerHTML = `
               <div class="image-container"></div>
               <div class="performance-info">
                   <div class="performance-title">${escapeHtml(performance.prfnm)}</div>
                   <div class="performance-date">
                       <span>${performance.prfpdfrom}</span> ~
                       <span>${performance.prfpdto}</span>
                   </div>
                   <div class="performance-venue">${escapeHtml(performance.fcltynm)}</div>
               </div>
           `;

			const container = div.querySelector('.image-container');
			container.appendChild(img);

			return div;
		}

		function loadMorePerformances() {
			if (isLoading || !hasMoreData) return;

			isLoading = true;
			const spinner = document.querySelector('.loading-spinner');
			spinner.classList.add('show'); // 스크롤 시 로딩 스피너 표시

			const currentGenre = getCurrentGenre();
			if (!currentGenre) {
				console.error('Genre not found');
				return;
			}

			fetch(`/genre/more?page=${page + 1}&genre=${encodeURIComponent(currentGenre)}`)
				.then(response => {
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					return response.json();
				})
				.then(performances => {
					if (performances && performances.length > 0) {
						const grid = document.getElementById('performanceGrid');
						performances.forEach(performance => {
							const performanceElement = createPerformanceElement(performance);
							grid.appendChild(performanceElement);
						});
						page += 1;
					} else {
						hasMoreData = false; // 더 이상 데이터가 없을 경우
					}
				})
				.catch(error => {
					console.error('Error loading performances:', error);
					hasMoreData = false;
				})
				.finally(() => {
					isLoading = false;
					spinner.classList.remove('show'); // 로딩 완료 후 스피너 숨기기
				});
		}

		// lodash의 throttle 대신 자체 구현
		function throttle(func, limit) {
			let inThrottle;
			return function (...args) {
				if (!inThrottle) {
					func.apply(this, args);
					inThrottle = true;
					setTimeout(() => inThrottle = false, limit);
				}
			}
		}

		// 스크롤 핸들러 수정
		const scrollHandler = throttle(() => {
			if (isLoading || !hasMoreData) return;

			const {scrollTop, scrollHeight, clientHeight} = document.documentElement;

			if (scrollTop + clientHeight >= scrollHeight - 300) {
				loadMorePerformances();
			}
		}, 150);

		window.addEventListener('scroll', scrollHandler, {passive: true});

		window.addEventListener('unload', () => {
			window.removeEventListener('scroll', scrollHandler);
		});
	</script>
</body>

</html>